/* 
    Cebinae's egress flowtable data structure as standalone 
    lucid program for microbenchmarking. 
   - Extern measurement functions are implemented in egress.py
   - Symbolic values defined in egress.symv
*/


// configuration parameters 
const int nports = 32;

// flow table config -- set by egress.symb
symbolic size n_stages;
symbolic size log_slots_per_stage;
symbolic int slots_per_stage;

/* 
    want to eval with: 
    1 stage     /   4096 slots
    2 stages    /   2048 slots
    4 stages    /   1024 slots
*/

const int NULL = 0;

// stateful alu operations
memop add(int v, int ct){
    return v + ct;
}
memop fst(int a, int b) {
    return a;
}
memop write(int a, int b) {
    return b;
}
memop eq(int stored_value, int new_value){
    if (stored_value == new_value){
        return 1;
    } else {
        return 0;
    }
}
memop write_if_null(int memval, int pktval) {
    if (memval == NULL) {
        return pktval;
    }
    else {
        return memval;
    }
}
memop check_if_null(int memval, int newval) {
    if (memval == NULL) {
        return 1;
    }
    else {
        return 0;
    }
}

fun int<<log_slots_per_stage>> per_stage_hash(int stage, int src, int dst) {
    match stage with 
    | 0 -> {return hash<<log_slots_per_stage>>(101, src, dst);}
    | 1 -> {return hash<<log_slots_per_stage>>(173, src, dst);}
    | 2 -> {return hash<<log_slots_per_stage>>(233, src, dst);}
    | 3 -> {return hash<<log_slots_per_stage>>(263, src, dst);}
    | _ -> {return hash<<log_slots_per_stage>>(1, src, dst);}
}

// measurement function externs -- used by interpreter only
extern log_groundtruth_flowtable_update(int src, int dst, int pkt_len);
extern log_real_flowtable_update(int stage, int slot, int src, int dst, int count);
extern calculate_accuracy(int interval, int trial, int d);


// Module for a single stage of the flow table
module HashStage : {
    global type hashstage_t<<'log_slots>>;
    constr hashstage_t<<'log_slots>> create(int slots, int stage_num);
    fun bool try_insert(hashstage_t<<'log_slots>> hs, int src, int dst, int pkt_len) [start <= hs; end hs];
} 
{
    type hashstage_t<<'log_slots>> = {
        int stage_num;
        Array.t<<32>> arr_src;
        Array.t<<32>> arr_dst;
        Array.t<<32>> arr_ct;
    }
    constr hashstage_t<<'log_slots>> create(int slots, int stage_num) = {
        stage_num = stage_num;
        arr_src = Array.create(slots);
        arr_dst = Array.create(slots);
        arr_ct = Array.create(slots);
    };
    // if (src, dst) is in hash table, increment and return true; 
    // elif table[hash((src, dst))] is free, insert a new entry and return true;
    // else do nothing and return false
    fun bool try_insert(hashstage_t<<'log_slots>> hs, int src, int dst, int pkt_len) {
        bool inserted = false;

        int<<'log_slots>> h = per_stage_hash(hs#stage_num, src, dst);
        printf ("log_slots: %d",size_to_int(log_slots_per_stage));
        printf("h: %d", h);
        int stored_src = Array.update(hs#arr_src, h, 
            fst, NULL, write_if_null, src);
        int stored_dst = Array.update(hs#arr_dst, h, 
            fst, NULL, write_if_null, dst);
        if ((stored_src == NULL && stored_dst == NULL) || 
            (stored_src == src && stored_dst == dst)) {
            inserted = true;
            int flowlen = Array.update(hs#arr_ct, h, add, pkt_len, add, pkt_len); // increment.        
            // update the extern copy of the dataplane flow table.
            log_real_flowtable_update(0, (int<<32>>)h, src, dst, flowlen); 
        }
        return inserted;
    }
}


// port counter
global Array.t<<32>> port_cts = Array.create(nports);




// const int[n_stages] foo = seeds;


// multi-stage flow counter
global HashStage.hashstage_t<<log_slots_per_stage>>[n_stages] hashstages 
    = [HashStage.create(slots_per_stage, ((size_to_int(i)))) for i < n_stages];




event Cebinae_egress(int port, int src, int dst, int pkt_len) {
    Array.setm(port_cts, port, add, pkt_len); // increment port counter

    // update stages of flow table until you find a slot for this flow
    bool inserted = false;
    for (i < n_stages) {
        if (!inserted) {
            inserted = HashStage.try_insert(hashstages[i], src, dst, pkt_len);
        }
    }
    // for measurement
    log_groundtruth_flowtable_update(src, dst, pkt_len);
}

event finish_trial(int interval, int trial, int d) {
    // calculate accuracy based on groundtruth and data plane flow tables.
    calculate_accuracy(interval, trial, d);
}
